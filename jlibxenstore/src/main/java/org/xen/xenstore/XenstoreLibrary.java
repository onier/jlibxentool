package org.xen.xenstore;

import com.sun.jna.Library;
import com.sun.jna.Native;
import com.sun.jna.NativeLibrary;
import com.sun.jna.NativeLong;
import com.sun.jna.Pointer;
import com.sun.jna.PointerType;
import com.sun.jna.ptr.IntByReference;
import com.sun.jna.ptr.PointerByReference;
import java.nio.IntBuffer;

/**
 * JNA Wrapper for library <b>xenstore</b><br>
 * This file was autogenerated by
 * <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that
 * <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a
 * few opensource projects.</a>.<br>
 * For help, please visit
 * <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> ,
 * <a href="http://rococoa.dev.java.net/">Rococoa</a>, or
 * <a href="http://jna.dev.java.net/">JNA</a>.
 */
public interface XenstoreLibrary extends Library {

    public static final String JNA_LIBRARY_NAME = "xenstore";
    public static final NativeLibrary JNA_NATIVE_LIB = NativeLibrary.getInstance(XenstoreLibrary.JNA_LIBRARY_NAME);
    public static final XenstoreLibrary INSTANCE = (XenstoreLibrary) Native.loadLibrary(XenstoreLibrary.JNA_LIBRARY_NAME, XenstoreLibrary.class);
    public static final int XBT_NULL = (int) 0;
    public static final int XS_UNWATCH_FILTER = (int) (1 << 2);
    public static final int XS_OPEN_SOCKETONLY = (int) (1 << 1);
    public static final int XS_OPEN_READONLY = (int) (1 << 0);

    /**
     * Open a connection to the xs daemon.<br>
     * Attempts to make a connection over the socket interface, <br>
     * and if it fails, then over the xenbus interface.<br>
     * Mode 0 specifies read-write access, XS_OPEN_READONLY for<br>
     * read-only access.<br>
     * Returns a handle or NULL.<br>
     * Original signature : <code>xs_handle* xs_open(unsigned long)</code><br>
     * <i>native declaration : line 68</i>
     */
    XenstoreLibrary.xs_handle xs_open(NativeLong flags);

    /**
     * Close the connection to the xs daemon.<br>
     * Original signature : <code>void xs_close(xs_handle*)</code><br>
     * <i>native declaration : line 71</i>
     */
    void xs_close(XenstoreLibrary.xs_handle xsh);

    /**
     * Connect to the xs daemon.<br>
     * Returns a handle or NULL.<br>
     * Deprecated, please use xs_open(0) instead<br>
     * Original signature : <code>xs_handle* xs_daemon_open()</code><br>
     * <i>native declaration : line 77</i>
     */
    XenstoreLibrary.xs_handle xs_daemon_open();

    /**
     * Original signature : <code>xs_handle* xs_domain_open()</code><br>
     * <i>native declaration : line 78</i>
     */
    XenstoreLibrary.xs_handle xs_domain_open();

    /**
     * Connect to the xs daemon (readonly for non-root clients).<br>
     * Returns a handle or NULL.<br>
     * Deprecated, please use xs_open(XS_OPEN_READONLY) instead<br>
     * Original signature :
     * <code>xs_handle* xs_daemon_open_readonly()</code><br>
     * <i>native declaration : line 84</i>
     */
    XenstoreLibrary.xs_handle xs_daemon_open_readonly();

    /**
     * Close the connection to the xs daemon.<br>
     * Deprecated, please use xs_close() instead<br>
     * Original signature : <code>void xs_daemon_close(xs_handle*)</code><br>
     * <i>native declaration : line 89</i>
     */
    void xs_daemon_close(XenstoreLibrary.xs_handle xs_handlePtr1);

    /**
     * Throw away the connection to the xs daemon, for use after fork().<br>
     * Original signature :
     * <code>void xs_daemon_destroy_postfork(xs_handle*)</code><br>
     * <i>native declaration : line 92</i>
     */
    void xs_daemon_destroy_postfork(XenstoreLibrary.xs_handle xs_handlePtr1);

    /**
     * Get contents of a directory.<br>
     * Returns a malloced array: call free() on it after use.<br>
     * Num indicates size.<br>
     * Original signature :
     * <code>char** xs_directory(xs_handle*, xs_transaction_t, const char*, unsigned int*)</code><br>
     * <i>native declaration : line 98</i><br>
     *
     * @deprecated use the safer methods
     * {@link #xs_directory(xenstore.XenstoreLibrary.xs_handle, int, java.lang.String, java.nio.IntBuffer)}
     * and
     * {@link #xs_directory(xenstore.XenstoreLibrary.xs_handle, int, com.sun.jna.Pointer, com.sun.jna.ptr.IntByReference)}
     * instead
     */
    @Deprecated
    PointerByReference xs_directory(XenstoreLibrary.xs_handle h, int t, Pointer path, IntByReference num);

    /**
     * Get contents of a directory.<br>
     * Returns a malloced array: call free() on it after use.<br>
     * Num indicates size.<br>
     * Original signature :
     * <code>char** xs_directory(xs_handle*, xs_transaction_t, const char*, unsigned int*)</code><br>
     * <i>native declaration : line 98</i>
     */
    PointerByReference xs_directory(XenstoreLibrary.xs_handle h, int t, String path, IntBuffer num);

    /**
     * Get the value of a single file, nul terminated.<br>
     * Returns a malloced value: call free() on it after use.<br>
     * len indicates length in bytes, not including terminator.<br>
     * Original signature :
     * <code>void* xs_read(xs_handle*, xs_transaction_t, const char*, unsigned int*)</code><br>
     * <i>native declaration : line 105</i><br>
     *
     * @deprecated use the safer methods
     * {@link #xs_read(xenstore.XenstoreLibrary.xs_handle, int, java.lang.String, java.nio.IntBuffer)}
     * and
     * {@link #xs_read(xenstore.XenstoreLibrary.xs_handle, int, com.sun.jna.Pointer, com.sun.jna.ptr.IntByReference)}
     * instead
     */
    @Deprecated
    Pointer xs_read(XenstoreLibrary.xs_handle h, int t, Pointer path, IntByReference len);

    /**
     * Get the value of a single file, nul terminated.<br>
     * Returns a malloced value: call free() on it after use.<br>
     * len indicates length in bytes, not including terminator.<br>
     * Original signature :
     * <code>void* xs_read(xs_handle*, xs_transaction_t, const char*, unsigned int*)</code><br>
     * <i>native declaration : line 105</i>
     */
    Pointer xs_read(XenstoreLibrary.xs_handle h, int t, String path, IntBuffer len);

    /**
     * Write the value of a single file.<br>
     * Returns false on failure.<br>
     * Original signature :
     * <code>bool xs_write(xs_handle*, xs_transaction_t, const char*, const void*, unsigned int)</code><br>
     * <i>native declaration : line 111</i><br>
     *
     * @deprecated use the safer methods
     * {@link #xs_write(xenstore.XenstoreLibrary.xs_handle, int, java.lang.String, com.sun.jna.Pointer, int)}
     * and
     * {@link #xs_write(xenstore.XenstoreLibrary.xs_handle, int, com.sun.jna.Pointer, com.sun.jna.Pointer, int)}
     * instead
     */
    @Deprecated
    byte xs_write(XenstoreLibrary.xs_handle h, int t, Pointer path, Pointer data, int len);

    /**
     * Write the value of a single file.<br>
     * Returns false on failure.<br>
     * Original signature :
     * <code>bool xs_write(xs_handle*, xs_transaction_t, const char*, const void*, unsigned int)</code><br>
     * <i>native declaration : line 111</i>
     */
    byte xs_write(XenstoreLibrary.xs_handle h, int t, String path, Pointer data, int len);

    /**
     * Create a new directory.<br>
     * Returns false on failure, or success if it already exists.<br>
     * Original signature :
     * <code>bool xs_mkdir(xs_handle*, xs_transaction_t, const char*)</code><br>
     * <i>native declaration : line 117</i><br>
     *
     * @deprecated use the safer methods
     * {@link #xs_mkdir(xenstore.XenstoreLibrary.xs_handle, int, java.lang.String)}
     * and
     * {@link #xs_mkdir(xenstore.XenstoreLibrary.xs_handle, int, com.sun.jna.Pointer)}
     * instead
     */
    @Deprecated
    byte xs_mkdir(XenstoreLibrary.xs_handle h, int t, Pointer path);

    /**
     * Create a new directory.<br>
     * Returns false on failure, or success if it already exists.<br>
     * Original signature :
     * <code>bool xs_mkdir(xs_handle*, xs_transaction_t, const char*)</code><br>
     * <i>native declaration : line 117</i>
     */
    byte xs_mkdir(XenstoreLibrary.xs_handle h, int t, String path);

    /**
     * Destroy a file or directory (and children).<br>
     * Returns false on failure, or if it doesn't exist.<br>
     * Original signature :
     * <code>bool xs_rm(xs_handle*, xs_transaction_t, const char*)</code><br>
     * <i>native declaration : line 123</i><br>
     *
     * @deprecated use the safer methods
     * {@link #xs_rm(xenstore.XenstoreLibrary.xs_handle, int, java.lang.String)}
     * and
     * {@link #xs_rm(xenstore.XenstoreLibrary.xs_handle, int, com.sun.jna.Pointer)}
     * instead
     */
    @Deprecated
    byte xs_rm(XenstoreLibrary.xs_handle h, int t, Pointer path);

    /**
     * Destroy a file or directory (and children).<br>
     * Returns false on failure, or if it doesn't exist.<br>
     * Original signature :
     * <code>bool xs_rm(xs_handle*, xs_transaction_t, const char*)</code><br>
     * <i>native declaration : line 123</i>
     */
    byte xs_rm(XenstoreLibrary.xs_handle h, int t, String path);

    /**
     * Restrict a xenstore handle so that it acts as if it had the<br>
     * permissions of domain @domid. The handle must currently be<br>
     * using domain 0's credentials.<br>
     * * Returns false on failure, in which case the handle continues<br>
     * to use the old credentials, or true on success.<br>
     * Original signature :
     * <code>bool xs_restrict(xs_handle*, unsigned)</code><br>
     * <i>native declaration : line 133</i>
     */
    byte xs_restrict(XenstoreLibrary.xs_handle h, int domid);

    /**
     * Get permissions of node (first element is owner, first perms is
     * "other").<br>
     * Returns malloced array, or NULL: call free() after use.<br>
     * Original signature :
     * <code>xs_permissions* xs_get_permissions(xs_handle*, xs_transaction_t, const char*, unsigned int*)</code><br>
     * <i>native declaration : line 138</i><br>
     *
     * @deprecated use the safer methods
     * {@link #xs_get_permissions(xenstore.XenstoreLibrary.xs_handle, int, java.lang.String, java.nio.IntBuffer)}
     * and
     * {@link #xs_get_permissions(xenstore.XenstoreLibrary.xs_handle, int, com.sun.jna.Pointer, com.sun.jna.ptr.IntByReference)}
     * instead
     */
    @Deprecated
    XenstoreLibrary.xs_permissions xs_get_permissions(XenstoreLibrary.xs_handle h, int t, Pointer path, IntByReference num);

    /**
     * Get permissions of node (first element is owner, first perms is
     * "other").<br>
     * Returns malloced array, or NULL: call free() after use.<br>
     * Original signature :
     * <code>xs_permissions* xs_get_permissions(xs_handle*, xs_transaction_t, const char*, unsigned int*)</code><br>
     * <i>native declaration : line 138</i>
     */
    XenstoreLibrary.xs_permissions xs_get_permissions(XenstoreLibrary.xs_handle h, int t, String path, IntBuffer num);

    /**
     * Set permissions of node (must be owner).<br>
     * Returns false on failure.<br>
     * Original signature :
     * <code>bool xs_set_permissions(xs_handle*, xs_transaction_t, const char*, xs_permissions*, unsigned int)</code><br>
     * <i>native declaration : line 145</i><br>
     *
     * @deprecated use the safer methods
     * {@link #xs_set_permissions(xenstore.XenstoreLibrary.xs_handle, int, java.lang.String, xenstore.XenstoreLibrary.xs_permissions, int)}
     * and
     * {@link #xs_set_permissions(xenstore.XenstoreLibrary.xs_handle, int, com.sun.jna.Pointer, xenstore.XenstoreLibrary.xs_permissions, int)}
     * instead
     */
    @Deprecated
    byte xs_set_permissions(XenstoreLibrary.xs_handle h, int t, Pointer path, XenstoreLibrary.xs_permissions perms, int num_perms);

    /**
     * Set permissions of node (must be owner).<br>
     * Returns false on failure.<br>
     * Original signature :
     * <code>bool xs_set_permissions(xs_handle*, xs_transaction_t, const char*, xs_permissions*, unsigned int)</code><br>
     * <i>native declaration : line 145</i>
     */
    byte xs_set_permissions(XenstoreLibrary.xs_handle h, int t, String path, XenstoreLibrary.xs_permissions perms, int num_perms);

    /**
     * Watch a node for changes (poll on fd to detect, or call
     * read_watch()).<br>
     * When the node (or any child) changes, fd will become readable.<br>
     * Token is returned when watch is read, to allow matching.<br>
     * Returns false on failure.<br>
     * Original signature :
     * <code>bool xs_watch(xs_handle*, const char*, const char*)</code><br>
     * <i>native declaration : line 154</i><br>
     *
     * @deprecated use the safer methods
     * {@link #xs_watch(xenstore.XenstoreLibrary.xs_handle, java.lang.String, java.lang.String)}
     * and
     * {@link #xs_watch(xenstore.XenstoreLibrary.xs_handle, com.sun.jna.Pointer, com.sun.jna.Pointer)}
     * instead
     */
    @Deprecated
    byte xs_watch(XenstoreLibrary.xs_handle h, Pointer path, Pointer token);

    /**
     * Watch a node for changes (poll on fd to detect, or call
     * read_watch()).<br>
     * When the node (or any child) changes, fd will become readable.<br>
     * Token is returned when watch is read, to allow matching.<br>
     * Returns false on failure.<br>
     * Original signature :
     * <code>bool xs_watch(xs_handle*, const char*, const char*)</code><br>
     * <i>native declaration : line 154</i>
     */
    byte xs_watch(XenstoreLibrary.xs_handle h, String path, String token);

    /**
     * Return the FD to poll on to see if a watch has fired.<br>
     * Original signature : <code>int xs_fileno(xs_handle*)</code><br>
     * <i>native declaration : line 157</i>
     */
    int xs_fileno(XenstoreLibrary.xs_handle h);

    /**
     * Check for node changes. On success, returns a non-NULL pointer ret<br>
     * such that ret[0] and ret[1] are valid C strings, namely the<br>
     * triggering path (see docs/misc/xenstore.txt) and the token (from<br>
     * xs_watch). On error return value is NULL setting errno.<br>
     * <br>
     * Callers should, after xs_fileno has become readable, repeatedly<br>
     * call xs_check_watch until it returns NULL and sets errno to EAGAIN.<br>
     * (If the fd became readable, xs_check_watch is allowed to make it no<br>
     * longer show up as readable even if future calls to xs_check_watch<br>
     * will return more watch events.)<br>
     * * After the caller is finished with the returned information it<br>
     * should be freed all in one go with free(ret).<br>
     * Original signature : <code>char** xs_check_watch(xs_handle*)</code><br>
     * <i>native declaration : line 173</i>
     */
    PointerByReference xs_check_watch(XenstoreLibrary.xs_handle h);

    /**
     * Find out what node change was on (will block if nothing pending).<br>
     * Returns array containing the path and token. Use XS_WATCH_* to access
     * these<br>
     * elements. Call free() after use.<br>
     * Original signature :
     * <code>char** xs_read_watch(xs_handle*, unsigned int*)</code><br>
     * <i>native declaration : line 179</i><br>
     *
     * @deprecated use the safer methods
     * {@link #xs_read_watch(xenstore.XenstoreLibrary.xs_handle, java.nio.IntBuffer)}
     * and
     * {@link #xs_read_watch(xenstore.XenstoreLibrary.xs_handle, com.sun.jna.ptr.IntByReference)}
     * instead
     */
    @Deprecated
    PointerByReference xs_read_watch(XenstoreLibrary.xs_handle h, IntByReference num);

    /**
     * Find out what node change was on (will block if nothing pending).<br>
     * Returns array containing the path and token. Use XS_WATCH_* to access
     * these<br>
     * elements. Call free() after use.<br>
     * Original signature :
     * <code>char** xs_read_watch(xs_handle*, unsigned int*)</code><br>
     * <i>native declaration : line 179</i>
     */
    PointerByReference xs_read_watch(XenstoreLibrary.xs_handle h, IntBuffer num);

    /**
     * Remove a watch on a node: implicitly acks any outstanding watch.<br>
     * Returns false on failure (no watch on that node).<br>
     * Original signature :
     * <code>bool xs_unwatch(xs_handle*, const char*, const char*)</code><br>
     * <i>native declaration : line 184</i><br>
     *
     * @deprecated use the safer methods
     * {@link #xs_unwatch(xenstore.XenstoreLibrary.xs_handle, java.lang.String, java.lang.String)}
     * and
     * {@link #xs_unwatch(xenstore.XenstoreLibrary.xs_handle, com.sun.jna.Pointer, com.sun.jna.Pointer)}
     * instead
     */
    @Deprecated
    byte xs_unwatch(XenstoreLibrary.xs_handle h, Pointer path, Pointer token);

    /**
     * Remove a watch on a node: implicitly acks any outstanding watch.<br>
     * Returns false on failure (no watch on that node).<br>
     * Original signature :
     * <code>bool xs_unwatch(xs_handle*, const char*, const char*)</code><br>
     * <i>native declaration : line 184</i>
     */
    byte xs_unwatch(XenstoreLibrary.xs_handle h, String path, String token);

    /**
     * Start a transaction: changes by others will not be seen during this<br>
     * transaction, and changes will not be visible to others until end.<br>
     * Returns NULL on failure.<br>
     * Original signature :
     * <code>xs_transaction_t xs_transaction_start(xs_handle*)</code><br>
     * <i>native declaration : line 190</i>
     */
    int xs_transaction_start(XenstoreLibrary.xs_handle h);

    /**
     * End a transaction.<br>
     * If abandon is true, transaction is discarded instead of committed.<br>
     * Returns false on failure: if errno == EAGAIN, you have to restart<br>
     * transaction.<br>
     * Original signature :
     * <code>bool xs_transaction_end(xs_handle*, xs_transaction_t, bool)</code><br>
     * <i>native declaration : line 197</i>
     */
    byte xs_transaction_end(XenstoreLibrary.xs_handle h, int t, byte abort);

    /**
     * Introduce a new domain.<br>
     * This tells the store daemon about a shared memory page, event channel
     * and<br>
     * store path associated with a domain: the domain uses these to
     * communicate.<br>
     * Original signature :
     * <code>bool xs_introduce_domain(xs_handle*, unsigned int, unsigned long, unsigned int)</code><br>
     * <i>native declaration : line 204</i>
     */
    byte xs_introduce_domain(XenstoreLibrary.xs_handle h, int domid, NativeLong mfn, int eventchn);

    /**
     * Set the target of a domain<br>
     * This tells the store daemon that a domain is targetting another one,
     * so<br>
     * it should let it tinker with it.<br>
     * Original signature :
     * <code>bool xs_set_target(xs_handle*, unsigned int, unsigned int)</code><br>
     * <i>native declaration : line 213</i>
     */
    byte xs_set_target(XenstoreLibrary.xs_handle h, int domid, int target);

    /**
     * Resume a domain.<br>
     * Clear the shutdown flag for this domain in the store.<br>
     * Original signature :
     * <code>bool xs_resume_domain(xs_handle*, unsigned int)</code><br>
     * <i>native declaration : line 220</i>
     */
    byte xs_resume_domain(XenstoreLibrary.xs_handle h, int domid);

    /**
     * Release a domain.<br>
     * Tells the store domain to release the memory page to the domain.<br>
     * Original signature :
     * <code>bool xs_release_domain(xs_handle*, unsigned int)</code><br>
     * <i>native declaration : line 225</i>
     */
    byte xs_release_domain(XenstoreLibrary.xs_handle h, int domid);

    /**
     * Query the home path of a domain. Call free() after use.<br>
     * Original signature :
     * <code>char* xs_get_domain_path(xs_handle*, unsigned int)</code><br>
     * <i>native declaration : line 229</i>
     */
    Pointer xs_get_domain_path(XenstoreLibrary.xs_handle h, int domid);

    /**
     * Returns true if child is either equal to parent, or a node underneath<br>
     * parent; or false otherwise. Done by string comparison, so relative
     * and<br>
     * absolute pathnames never in a parent/child relationship by this<br>
     * definition. Cannot fail.<br>
     * Original signature :
     * <code>bool xs_path_is_subpath(const char*, const char*)</code><br>
     * <i>native declaration : line 236</i><br>
     *
     * @deprecated use the safer methods
     * {@link #xs_path_is_subpath(java.lang.String, java.lang.String)} and
     * {@link #xs_path_is_subpath(com.sun.jna.Pointer, com.sun.jna.Pointer)}
     * instead
     */
    @Deprecated
    byte xs_path_is_subpath(Pointer parent, Pointer child);

    /**
     * Returns true if child is either equal to parent, or a node underneath<br>
     * parent; or false otherwise. Done by string comparison, so relative
     * and<br>
     * absolute pathnames never in a parent/child relationship by this<br>
     * definition. Cannot fail.<br>
     * Original signature :
     * <code>bool xs_path_is_subpath(const char*, const char*)</code><br>
     * <i>native declaration : line 236</i>
     */
    byte xs_path_is_subpath(String parent, String child);

    /**
     * Return whether the domain specified has been introduced to xenstored.<br>
     * Original signature :
     * <code>bool xs_is_domain_introduced(xs_handle*, unsigned int)</code><br>
     * <i>native declaration : line 240</i>
     */
    byte xs_is_domain_introduced(XenstoreLibrary.xs_handle h, int domid);

    /**
     * Only useful for DEBUG versions<br>
     * Original signature :
     * <code>char* xs_debug_command(xs_handle*, const char*, void*, unsigned int)</code><br>
     * <i>native declaration : line 243</i><br>
     *
     * @deprecated use the safer methods
     * {@link #xs_debug_command(xenstore.XenstoreLibrary.xs_handle, java.lang.String, com.sun.jna.Pointer, int)}
     * and
     * {@link #xs_debug_command(xenstore.XenstoreLibrary.xs_handle, com.sun.jna.Pointer, com.sun.jna.Pointer, int)}
     * instead
     */
    @Deprecated
    Pointer xs_debug_command(XenstoreLibrary.xs_handle h, Pointer cmd, Pointer data, int len);

    /**
     * Only useful for DEBUG versions<br>
     * Original signature :
     * <code>char* xs_debug_command(xs_handle*, const char*, void*, unsigned int)</code><br>
     * <i>native declaration : line 243</i>
     */
    Pointer xs_debug_command(XenstoreLibrary.xs_handle h, String cmd, Pointer data, int len);

    /**
     * Original signature : <code>int xs_suspend_evtchn_port(int)</code><br>
     * <i>native declaration : line 246</i>
     */
    int xs_suspend_evtchn_port(int domid);

    public static class xs_handle extends PointerType {

        public xs_handle(Pointer address) {
            super(address);
        }

        public xs_handle() {
            super();
        }
    };

    public static class xs_permissions extends PointerType {

        public xs_permissions(Pointer address) {
            super(address);
        }

        public xs_permissions() {
            super();
        }
    };
}
